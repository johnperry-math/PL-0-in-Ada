with Ada.Text_IO; use Ada.Text_IO;
with Ada.Integer_Text_IO; use Ada.Integer_Text_IO;

with Ada.Characters.Handling; use Ada.Characters.Handling;
with Ada.Characters.Latin_1; use Ada.Characters.Latin_1;

with Ada.Strings.Bounded;

with Ada.Containers.Ordered_Maps;
with Ada.Containers.Ordered_Sets;
with Ada.Containers.Vectors;

package body Compiler is

type Errors is (
  SEMICOLON,
  IDENT,
  UNKNOWN,
  ASSIGN,
  ASSIGN_PROC,
  END_SYM,
  DO_SYM,
  THEN_SYM,
  VARIABLE,
  RPAREN,
  IS_PROCEDURE,
  PROG_SIZE,
  END_PROG,
  NUMBER_EXPECTED,
  LPAREN,
  REL,
  NUMBER_IDENT,
  NOPROCEDURE,
  EXPECT_UNTIL,
  TO_OR_DOWNTO,
  EXPECT_OF,
  COLON,
  CASE_NEEDS_CONSTANT,
  FOR_NEEDS_VARIABLE,
  TOO_MANY_THREADS,
  ARRAY_EXPECTS_SIZE,
  ARRAY_EXPECTS_INDEX,
  ARRAY_DECLARATION_REQUIRES_BRACKETS
);

package String_Max80 is new Ada.Strings.Bounded.Generic_Bounded_Length(80);
use String_Max80;

Error_Messages: array(Errors) of Bounded_String := (
  To_Bounded_String("Procedure not accepted here"),
  To_Bounded_String("number or ident expected"),
  To_Bounded_String("Assignment operator expected"),
  To_Bounded_String("Assignment not allowed here"),
  To_Bounded_String("Premature end of program"),
  To_Bounded_String("DO symbol Expected"),
  To_Bounded_String("END symbol Expected"),
  To_Bounded_String("Identifier Expected"),
  To_Bounded_String("Assignment to PROCEDURE not allowed"),
  To_Bounded_String("A number was Expected"),
  To_Bounded_String("Program size is too large..."),
  To_Bounded_String("RIGHT Parenthesis Expected"),
  To_Bounded_String("LEFT Parenthesis Expected"),
  To_Bounded_String("Semicolon Expected"),
  To_Bounded_String("THEN symbol Expected"),
  To_Bounded_String("Unknown Identifier"),
  To_Bounded_String("Variable or Expression Expected"),
  To_Bounded_String("Relational operator expected"),
  To_Bounded_String("UNTIL symbol expected"),
  To_Bounded_String("TO or DOWNTO symbol expected"),
  To_Bounded_String("OF symbol expected"),
  To_Bounded_String("Colon expected"),
  To_Bounded_String("For loops require a declared variable"),
  To_Bounded_String("Cases must be constants"),
  To_Bounded_String("Too many threads open already, cannot start a new one"),
  To_Bounded_String("Must specify a size for an array"),
  To_Bounded_String("Can only access arrays through indices"),
  To_Bounded_String(
      "Specify array size with a number in brackets [...] after name"
  )
);

procedure Error(num: Errors) is
  Compile_Error: exception;
begin
  New_Line(1);
  Put(To_String(error_messages(num)));
  New_Line(1);
  raise Compile_Error;
end Error;

type Symbol is (
	VARSYM,
	CONSTSYM,
	BEGINSYM,
	ENDSYM,
	PERIOD,
	SEMICOLON,
	COLON,
	LPAREN,
	RPAREN,
	NOTEQL,
	GRTHEN,
	LSTHEN,
	GREQL,
	LSEQL,
	EQL,
	ASSIGN,
	IFSYM,
	IDENT,
	NUM,
	PROCSYM,
	MINUS,
	PLUS,
	DIV,
	MULT,
	COMMA,
	ODDSYM,
	CALL,
	THENSYM,
	WHILESYM,
	DOSYM,
	ELSESYM,
	REPEATSYM,
	UNTILSYM,
	WRITESYM,
	WRITELNSYM,
	FORSYM,
	TOSYM,
	DOWNTOSYM,
	CASESYM,
	OFSYM,
	CENDSYM,
	ORSYM,
	ANDSYM,
	NOTSYM,
	COBEGINSYM,
	COENDSYM,
	THREADSYM,
	ARRAYSYM,
	LBRACKET,
	RBRACKET,
	MAX_SYMBOL
);

subtype Relation_Symbol is Symbol range NOTEQL..EQL;

relation_comments: array(Relation_Symbol) of String(1..3) := (
  "=?=",
  "=/=",
  "<? ",
  ">=?",
  ">? ",
  "<=?"
);

package Keyword_To_String is new Ada.Containers.Ordered_Maps(
  Key_Type     => Bounded_String,
  Element_Type => Symbol
);
use Keyword_To_String;
keyword_string_map: Map;

initialized_keyword_map: Boolean := false;

procedure Initialize_Keyword_Map is
begin
  Include(keyword_string_map, To_Bounded_String("AND"),       ANDSYM    );
  Include(keyword_string_map, To_Bounded_String("ARRAY"),     ARRAYSYM  );
  Include(keyword_string_map, To_Bounded_String("BEGIN"),     BEGINSYM  );
  Include(keyword_string_map, To_Bounded_String("CALL"),      CALL      );
  Include(keyword_string_map, To_Bounded_String("CASE"),      CASESYM   );
  Include(keyword_string_map, To_Bounded_String("CEND"),      CENDSYM   );
  Include(keyword_string_map, To_Bounded_String("COBEGIN"),   COBEGINSYM);
  Include(keyword_string_map, To_Bounded_String("COEND"),     COENDSYM  );
  Include(keyword_string_map, To_Bounded_String("CONST"),     CONSTSYM  );
  Include(keyword_string_map, To_Bounded_String("DO"),        DOSYM     );
  Include(keyword_string_map, To_Bounded_String("DOWNTO"),    DOWNTOSYM );
  Include(keyword_string_map, To_Bounded_String("ELSE"),      ELSESYM   );
  Include(keyword_string_map, To_Bounded_String("END"),       ENDSYM    );
  Include(keyword_string_map, To_Bounded_String("FOR"),       FORSYM    );
  Include(keyword_string_map, To_Bounded_String("IF"),        IFSYM     );
  Include(keyword_string_map, To_Bounded_String("NOT"),       NOTSYM    );
  Include(keyword_string_map, To_Bounded_String("ODD"),       ODDSYM    );
  Include(keyword_string_map, To_Bounded_String("OF"),        OFSYM     );
  Include(keyword_string_map, To_Bounded_String("OR"),        ORSYM     );
  Include(keyword_string_map, To_Bounded_String("PROCEDURE"), PROCSYM   );
  Include(keyword_string_map, To_Bounded_String("REPEAT"),    REPEATSYM );
  Include(keyword_string_map, To_Bounded_String("THEN"),      THENSYM   );
  Include(keyword_string_map, To_Bounded_String("THREAD"),    THREADSYM );
  Include(keyword_string_map, To_Bounded_String("TO"),        TOSYM     );
  Include(keyword_string_map, To_Bounded_String("UNTIL"),     UNTILSYM  );
  Include(keyword_string_map, To_Bounded_String("VAR"),       VARSYM    );
  Include(keyword_string_map, To_Bounded_String("WHILE"),     WHILESYM  );
  Include(keyword_string_map, To_Bounded_String("WRITE"),     WRITESYM  );
  Include(keyword_string_map, To_Bounded_String("WRITELN"),   WRITELNSYM);
end Initialize_Keyword_Map;

type Identifier_Type is (
  NONE,
  CONST,
  VAR,
  PROC,
  ARR
);

type Input_Type is ( ALPHA, DIGIT, EOL, NONE, PUNCT, WHITESPACE );
subtype Punct_Range is Character range Exclamation..Low_Line;

function Char_Type(ch: Character) return Input_Type is
  result: Input_Type := NONE;
begin
  if ch = LF or ch = CR then result := EOL;
  elsif Is_Letter(ch) then result := ALPHA;
  elsif Is_Digit(ch)  then result := DIGIT;
  elsif ch = Space or ch = HT then result := WHITESPACE;
  elsif ch in Punct_Range then result := PUNCT;
  end if;
  return result;
end Char_Type;

line:   Bounded_String;
punc:   Bounded_String;
number: Integer;

linelength: Integer := 0;
linecount:  Integer := 0;
charcount:  Integer := 0;

read_line: Bounded_String;

procedure Get_Char(ch: out Character) is
begin
  if charcount = linelength then
    charcount := 0;
    linelength := 0;
    read_line := Null_Bounded_String;
    Get(ch);
    while Char_Type(ch) /= EOL loop
      Append(read_line, ch);
      Get(ch);
      linelength := linelength + 1;
    end loop;
    if linelength = 0 and charcount = 0 then
      Error(END_PROG);
    end if;
    
    Put(To_String(read_line));
    New_Line(1);
    
    linecount := linecount + 1;
    linelength := linelength + 1;
  end if;
end Get_Char;

type Digit_Range is new Natural range 0..9;

function Ordinal(ch: Character) return Digit_Range is
  result: Digit_Range;
begin
  case ch is
    when '0'..'9' => result := Character'Pos(ch) - Character'Pos('0');
    when others => raise Program_Error;
  end case;
  return result;
end Ordinal;

procedure Get_Symbol(sym: in out Symbol) is
  ch:       Character;
  ch_type:  Input_Type;
  index:    Integer := 0;
begin
  loop
    Get_Char(ch);
    ch_type := Char_Type(ch);
    exit when ch_type /= WHITESPACE and ch_type /= EOL;
  end loop;
  if Char_Type(ch) = ALPHA then
    line := Null_Bounded_String;
    loop
      Append(line, ch);
      Get_Char(ch);
      exit when Char_Type(ch) /= ALPHA and Char_Type(ch) /= DIGIT and ch /= '_';
    end loop;
    charcount := charcount - 1;
    if Contains(keyword_string_map, line) then
      sym := Element(keyword_string_map, line);
    else
      sym := IDENT;
    end if;
  elsif Char_Type(ch) = DIGIT then
    sym := NUM;
    number := 0;
    loop
      number := 10 * number + Integer(Ordinal(ch));
      Get_Char(ch);
      exit when Char_Type(ch) /= DIGIT;
    end loop;
    charcount := charcount - 1;
  elsif Char_Type(ch) = PUNCT then
    punc := Null_Bounded_String;
    Append(punc, ch);
    if ch = ':' or ch = '<' or ch = '>' then
      Get_Char(ch);
      if Char_Type(ch) = PUNCT and (ch = '=' or ch = '>') then
        Append(punc, ch);
      else
        charcount := charcount - 1;
      end if;
    end if;
    if punc = ":=" then sym := ASSIGN;
    elsif punc = ":" then sym := COLON;
    elsif punc = "," then sym := COMMA;
    elsif punc = "/" then sym := DIV;
    elsif punc = "=" then sym := EQL;
    elsif punc = ">=" then sym := GREQL;
    elsif punc = ">" then sym := GRTHEN;
    elsif punc = "(" then sym := LPAREN;
    elsif punc = "<=" then sym := LSEQL;
    elsif punc = "<" then sym := LSTHEN;
    elsif punc = "-" then sym := MINUS;
    elsif punc = "*" then sym := MULT;
    elsif punc = "<>" then sym := NOTEQL;
    elsif punc = "." then sym := PERIOD;
    elsif punc = "+" then sym := PLUS;
    elsif punc = ")" then sym := RPAREN;
    elsif punc = ";" then sym := SEMICOLON;
    elsif punc = "[" then sym := LBRACKET;
    elsif punc = "]" then sym := RBRACKET;
    end if;
  end if;
end Get_Symbol;

type Symbol_Table_Entry is record
  name:   Bounded_String;
  kind:   Identifier_Type;
  value:  Integer;
  level:  Integer;
  adr:    Table_Range;
end record;

max_symbols: constant := 500;
type Symbol_Table_Range is range 0..max_symbols;
symbol_table: array(Symbol_Table_Range) of Symbol_Table_Entry;

procedure Enter(
  kind: Identifier_Type;
  name: Bounded_String;
  sym: in out Symbol;
  varcount: in out Table_Range;
  level: Integer;
  table_index: in out Symbol_Table_Range;
  size: Table_Range := 0
) is
begin
  table_index := table_index + 1;
  symbol_table(table_index).name := name;
  symbol_table(table_index).kind := kind;

  if kind = CONST then
    if sym /= IDENT then Error(IDENT); end if;
    Get_Symbol(sym);
    if sym /= EQL then Error(ASSIGN); end if;
    Get_Symbol(sym);
    if sym /= NUM then Error(NUMBER_EXPECTED); end if;
    symbol_table(table_index).value := number;
  elsif kind = VAR then
    if sym /= IDENT then Error(IDENT); end if;
    symbol_table(table_index).level := level;
    varcount := varcount + 1;
    symbol_table(table_index).adr   := varcount;
  elsif kind = ARR then
    symbol_table(table_index).level := level;
    symbol_table(table_index).adr   := varcount;
    varcount := varcount + size;
  elsif kind = PROC then
    symbol_table(table_index).level := level;
  end if;
  Get_Symbol(sym);
end Enter;

code_index: Table_Range := 0;

procedure Block(
  code: out PCode_Table;
  sym: Symbol;
  level: Integer;
  table_index: Symbol_Table_Range
) is
  varcount: Natural;
  start_table_index: Symbol_Table_Range;
begin
  varcount := 5;
  start_table_index := table_index;
  table(table_index).data := code_index;
  Gen(JMP, 0, 0);
  
  while sym = CONSTSYM or sym = VARSYM or sym = PROCSYM or sym = ARRAYSYM loop
    if sym = CONSTSYM then
      Get_Symbol(sym);
      Enter(CONST, line, sym, varcount, level, table_index);
      while sym = COMMA loop
        Get_Symbol(sym);
        Enter(CONST, line, sym, varcount, level, table_index);
      end loop;
      if sym /= SEMICOLON then Error(SEMICOLON); end if;
      Get_Symbol(sym);
    elsif sym = VARSYM then
      Get_Symbol(sym);
      Enter(VAR, line, sym, varcount, levl, table_index);
      while sym = COMMA loop
        Get_Symbol(sym);
        Enter(VAR, line, sym, varcount, levl, table_index);
      end loop;
      if sym /= SEMICOLON then Error(SEMICOLON); end if;
      Get_Symbol(sym);
    end if;
    while sym = PROCSYM loop
    end loop;
    while sym = ARRAYSYM loop
    end loop;
  end loop;
end Block;

procedure Compile(code: out PCode_Table) is
  sym: Symbol := NONE;
  level: Integer := 0;
  table_index: Symbol_Table_Range := 0;
begin
  Block(code, sym, level, table_index);
end Compile;

max_stack: constant := 1000;

package Stack_Vector is new Ada.Containers.Vectors(
  Element_Type => Integer,
  Index_Type   => Table_Range
);
use Stack_Vector;
type All_Stacks is array(Thread_Range) of Vector;
stacks: All_Stacks;

progregs: array(1..max_threads) of Table_Range;
baseregs: array(1..max_threads) of Table_Range;
tops:     array(1..max_threads) of Table_Range;

package Thread_Set is new Ada.Containers.Ordered_Sets(Thread_Range);
use Thread_Set;
threads_avail: Set;

type Caller_Data is record
  stack:    Thread_Range;
  location: Table_Range;
end record;

function Base(
  level: Integer;
  basereg: Table_Range;
  which_stack: Thread_Range;
  stacks: All_Stacks
) return Caller_Data is
  lev: Integer := level;
  new_stack: Thread_Range := which_stack;
  stack: Vector;
  new_base: Table_Range;
  base1: Table_Range := basereg;
  result: Caller_Data;
begin
  if (base1 = 0 and which_stack /= 0) then
    lev := lev + 1;
  end if;
  while lev > 0 loop
    stack := stacks(new_stack);
    new_base := Table_Range(Element(stack, Table_Range(base1)));
    new_stack := Thread_Range(Element(stack, base1 + 4));
    base1 := new_base;
    if base1 = 0 and new_stack /= 0 then
      lev := lev + 1;
    end if;
    lev := lev - 1;
  end loop;
  result := (new_stack, base1);
  return result;
end Base;

initialized_interpreter: Boolean := false;

procedure Interpret(codes: in PCode_Table; which_stack: Thread_Range) is
  stack: Vector;
  current_stack: Thread_Range := which_stack;
  progreg, top, basereg: Table_Range;
  code: PCode_Entry;
  caller: Caller_Data;
begin
  if not initialized_interpreter then
    for i in Thread_Range loop
      Reserve_Capacity(stacks(i), max_stack);
      Insert(threads_avail, i);
    end loop;
  end if;
  New_Line(1);
  Put("Start PL/0 #"); Put(Positive(current_stack), 2);
  New_Line(1);

  stack   := stacks   (current_stack);
  progreg := progregs (Positive(current_stack));
  top     := tops     (Positive(current_stack));
  basereg := baseregs (Positive(current_stack));

  loop
    code := codes(progreg);
    progreg := progreg + 1;
    case code.instruction is
      when LIT =>
        top := top + 1;
        stack(top) := code.data;
      when OPR =>
        case code.data is
          when 0 =>
            top           := basereg - 1;
            basereg       := Table_Range(Element(stack, top + 2));
            progreg       := Table_Range(Element(stack, top + 3));
            current_stack := Thread_Range(Element(stack, top + 4));
          when 1 => stack(top) := -stack(top);
          when 2 =>
            top := top - 1;
            stack(top) := stack(top) + stack(top + 1);
          when 3 =>
            top := top - 1;
            stack(top) := stack(top) - stack(top + 1);
          when 4 =>
            top := top - 1;
            stack(top) := stack(top) * stack(top + 1);
          when 5 =>
            top := top - 1;
            stack(top) := stack(top) / stack(top + 1);
          when 6 => stack(top) := stack(top) mod 2;
          when 8 =>
            top := top - 1;
            stack(top) := (
                if Element(stack, top) = Element(stack, top + 1) then 1 else 0
            );
          when 9 =>
            top := top - 1;
            stack(top) := (
                if Element(stack, top) /= Element(stack, top + 1) then 1 else 0
            );
          when 10 =>
            top := top - 1;
            stack(top) := ( if stack(top) < stack(top + 1) then 1 else 0 );
          when 11 =>
            top := top - 1;
            stack(top) := ( if stack(top) >= stack(top + 1) then 1 else 0 );
          when 12 =>
            top := top - 1;
            stack(top) := ( if stack(top) > stack(top + 1) then 1 else 0 );
          when 13 =>
            top := top - 1;
            stack(top) := ( if stack(top) <= stack(top + 1) then 1 else 0 );
          when 14 =>
            Put(stack(top), 0); Put(' ');
            top := top - 1;
          when 15 => New_Line(1);
          when others => stack(top) := stack(top);
        end case;
      when LOD =>
        top := top + 1;
        caller := Base(code.level, basereg, current_stack, stacks);
        stack(top) := stacks(caller.stack)(caller.location + Table_Range(code.data));
      when LDX =>
        caller := Base(code.level, basereg, current_stack, stacks);
        stack(top) := stacks(caller.stack)(caller.location + Table_Range(code.data) + Table_Range(Element(stack, top)));
      when STO =>
        caller := Base(code.level, basereg, current_stack, stacks);
        stacks(caller.stack)(caller.location + Table_Range(code.data)) := stack(top);
        top := top - 1;
      when STX =>
        caller := Base(code.level, basereg, current_stack, stacks);
        stacks(caller.stack)(caller.location + Table_Range(code.data) + Table_Range(Element(stack, top - 1))) := stack(top);
        top := top - 2;
      when CAL =>
        caller := Base(code.level, basereg, current_stack, stacks);
        Stack_Vector.Replace_Element(stack, top + 1, Integer(caller.location));
        Stack_Vector.Replace_Element(stack, top + 2, Integer(basereg));
        Stack_Vector.Replace_Element(stack, top + 3, Integer(progreg));
        Stack_Vector.Replace_Element(stack, top + 4, Integer(current_stack));
        Stack_Vector.Replace_Element(stack, top + 5, Integer(caller.stack));
        basereg := basereg + 1;
        progreg := Table_Range(code.data);
      when INT => top := top + Table_Range(code.data);
      when JMP => progreg := Table_Range(code.data);
      when JPC =>
        if stack(top) = code.level then
          progreg := Table_Range(code.data);
        end if;
      when CTS =>
        top := top + 1;
        stack(top) := stack(top - 1);
      when SNT =>
        stack(top) := stack(top); -- todo
      when RFT =>
        stack(top) := stack(top); -- todo
      when WFT =>
        stack(top) := stack(top); -- todo
      when THN =>
        top := top + 1;
        Replace_Element(stack, top, Integer(current_stack));
    end case;
    exit when progreg = 0;
  end loop;

  Insert(threads_avail, current_stack);
  Put("End PL/0 #"); Put(Positive(current_stack), 2);
  New_Line(1);
end Interpret;

instruction_string: array(PCode) of String(1..3) := (
  "OPR",
  "CAL",
  "INT",
  "JPC",
  "JMP",
  "LIT",
  "LOD",
  "STO",
  "CTS",
  "SNT",
  "RFT",
  "WFT",
  "THN",
  "STX",
  "LDX"
);

procedure Show_PCode(code: in PCODE_Table; start, stop: Table_Range) is
begin
  for i in start..stop loop
    Put(Positive(i), 4); Put(' ');
    Put(instruction_string(code(i).instruction)); Put(' ');
    Put(code(i).level, 4);
    Put(code(i).data, 4);
    if code(i).comment'Length /= 0 then
      Put(String(code(i).comment));
    end if;
    New_Line(1);
  end loop;
end Show_PCode;

end Compiler;